{"version":3,"sources":["jsdelivr-header.js","/npm/socket.io-mock@1.3.2/dist/index.js"],"names":[],"mappings":"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","file":"/npm/socket.io-mock@1.3.2/dist/index.js","sourceRoot":"","sourcesContent":["/**\n * Minified by jsDelivr using Terser v5.9.0.\n * Original file: /npm/socket.io-mock@1.3.2/dist/index.js\n *\n * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files\n */\n","'use strict';\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t  path: basedir,\n\t  exports: {},\n\t  require: function (path, base) {\n      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n    }\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar componentEmitter = createCommonjsModule(function (module) {\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\n{\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n}\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Remove event specific arrays for event types that no\r\n  // one is subscribed for to avoid memory leak.\r\n  if (callbacks.length === 0) {\r\n    delete this._callbacks['$' + event];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  var args = new Array(arguments.length - 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args[i - 1] = arguments[i];\r\n  }\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\n});\n\nclass SocketClient extends componentEmitter {\n  /**\n   * A mocking class for the Socket IO Client side\n   * @param {SocketMock} socketMock\n   */\n  constructor (socketMock) {\n    super();\n    this._socketMock = socketMock;\n    this._emitFn = componentEmitter.prototype.emit;\n    this.connected = true;\n    this.disconnected = false;\n  }\n\n  /**\n   * Emit an event to the server client\n   * @param  {string}   eventKey -- The event key that needs to be attached\n   * @param  {object}   payload  -- The payload that needs to be attached to the emit\n   * @param  {function} ack -- The ack argument is optional and will be called with the server answer.\n   */\n  emit (eventKey, ...args) {\n    let ack;\n    if (typeof args[args.length - 1] === 'function') {\n      ack = args.pop();\n    }\n    this._socketMock.emitEvent(eventKey, args, ack);\n  }\n\n  /**\n   * Fire an event to the server\n   * @param  {string}   eventKey -- The event key that needs to be attached\n   * @param  {object}   payload -- The payload that needs to be attached to the emit\n   * @param  {Function} callback\n   */\n  fireEvent (eventKey, payload) {\n    this._emitFn(eventKey, payload);\n  }\n\n  /**\n   * Close the socket\n   */\n  close () {\n    this.disconnected = true;\n    this.connected = false;\n    this.emit('disconnect', 'io client disconnect');\n    return this\n  }\n\n  /**\n   * Disconnet the socket alias for close\n   */\n  disconnect () {\n    return this.close()\n  }\n}\n\nconst createPayload = function (object) {\n  return object ? JSON.parse(JSON.stringify(object)) : undefined\n};\n\n/**\n * A mocking class for the Socket IO Server side\n */\nclass SocketMock extends componentEmitter {\n  /**\n   * Creates a new SocketMock instance\n  **/\n  constructor () {\n    super();\n    this.joinedRooms = this.rooms = [];\n    this.socketClient = new SocketClient(this);\n    this._emitFn = componentEmitter.prototype.emit;\n    this.generalCallbacks = {};\n    this.broadcast = {\n      /**\n       * Broadcast to room\n       * @param  {string} roomKey the roomkey which need to be attached to\n       * @return {object}\n      **/\n      to: roomKey => {\n        return {\n          /**\n           * Emitting\n           * @param  {string} eventKey\n           * @param  {object} payload\n          **/\n          emit: (eventKey, payload) => {\n            if (this.generalCallbacks[eventKey]) {\n              this.generalCallbacks[eventKey](createPayload(payload), roomKey);\n            }\n          }\n        }\n      }\n    };\n  }\n\n  /**\n   * Emit an event to the server (used by client)\n   * @param  {string} eventKey -- The event key\n   * @param  {object} payload -- Additional payload\n   * @param  {function} ack -- The ack argument is optional. When server call it payload reply will be delivered to client\n  **/\n  emitEvent (eventKey, args, ack) {\n    this._emitFn(eventKey, ...args.map(createPayload), ack);\n  }\n\n  /**\n   * Register on every event that the server sends\n   * @param {string} eventKey\n   * @param {Function} callback\n  **/\n  onEmit (eventKey, callback) {\n    this.generalCallbacks[eventKey] = callback;\n  }\n\n  /**\n   * Emit an event to the client\n   * @param  {string} eventKey -- The event key\n   * @param  {object} payload -- Additional payload\n  **/\n  emit (eventKey, payload) {\n    this.socketClient.fireEvent(eventKey, payload);\n  }\n\n  /**\n   * Joining a room\n   * @param  {string} roomKey The room we want to join\n  **/\n  join (roomKey) {\n    this.joinedRooms.push(roomKey);\n  }\n\n  /**\n   * Leaving a room\n   * @param  {string} roomKey The room you want to leave\n  **/\n  leave (roomKey) {\n    const index = this.joinedRooms.indexOf(roomKey);\n    this.joinedRooms.splice(index, 1);\n  }\n\n  /**\n   * Monitor logging feature\n   * @param  {string} value The value you want to monitor\n  **/\n  monitor (value) {\n    return value\n  }\n\n  /**\n   * Closing the socket server\n   * @param  {Function} cb\n   */\n  disconnect () {\n    this.emit('disconnecting', 'io server disconnect');\n    this.emit('disconnect', 'io server disconnect');\n    return this\n  }\n}\n\nmodule.exports = SocketMock;\n"]}